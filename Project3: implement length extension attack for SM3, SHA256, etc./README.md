> ## 原理阐释
> 长度扩展攻击（Length Extension Attack）是一种密码学攻击技术，用于破解基于哈希函数的认证与完整性保护机制。它利用了一些哈希函数（如MD5、SHA-1等）在处理消息时存在的漏洞。在正常情况下，哈希函数将输入消息作为输入并生成固定长度的摘要值。然而，在长度扩展攻击中，攻击者能够根据已知的哈希值和消息前缀构造出一个新的哈希值，而不需要知道原始消息内容。攻击的核心思想是通过构造合适的数据块来绕过哈希函数的内部状态更新，并生成有效的哈希扩展，从而让接收者误以为这是一个合法的哈希结果。为了防范长度扩展攻击，应该使用具有内置防护措施的哈希函数，例如HMAC。HMAC将密钥引入哈希计算的过程中，增加了攻击者对数据的控制难度。此外，推荐使用更安全的哈希函数，如SHA-256、SHA-3等，而不是已被证明存在问题的哈希函数，如MD5和SHA-1。总之，长度扩展攻击是一种危险的密码学攻击技术，可被用于欺骗基于哈希函数的认证与完整性保护机制。为了保护数据安全，我们应该使用具有内置防护措施并被广泛接受为安全的哈希函数。
>![实现原理](proof.png)
> 
>
>但是，长度扩展攻击其实对于哈希函数的威胁性并不大。因为，哈希函数的IV值是已知的，通过构造IV值来实现长度扩展攻击并没有什么意义。但是，长度扩展攻击对于攻击加盐的哈希函数或者伪造MAC值具有一定的效果。
> ## 代码说明
> 我们已经使用c++代码完成了SM3的实现。在此基础之上，我们构建两个字符串，“202100460120”和“abc”，来完成一个实例的具体攻击。具体代码细节实现如下：
> 
>    ```C++
>    def Rho_SM3(num):
      item=b"202100460120"
      Hash1=SM3(item)
      Hash2=SM3(Hash1)
      while(True):
          if(Hash1[0:num]!=Hash2[0:num]):
              Hash1=SM3(Hash1)
              Hash2=SM3(SM3(Hash2))
          else:
              print(Hash1)
              print(Hash2)
              break
> ``` python
> def Rho_SHA256(num):
      item=b"202100460120"
      Hash1=SHA256(item)
      Hash2=SHA256(Hash1)
      while(True):
          if(Hash1[0:num]!=Hash2[0:num]):
              Hash1=SHA256(Hash1)
              Hash2=SHA256(SHA256(Hash2))
          else:
              print(Hash1)
              print(Hash2)
              break

>
>
>观察上述代码可知,我将自己的学号输入，来作为初始项来寻找碰撞。我们可以看到当碰撞条件不成立时，这样两个hash值分别进行一次和两次的hash，从而形成“龟兔赛跑”之势。


>## 结果展示
>8bits
>![8bits](8bits.png)
>
>16bits
>![16bits](16bits.png)
>
>24bits
>![24bits](24bits.png)
>
>32bits
>![32bits](32bits.png)
>
>40bits
>![40bits](40bits.png)


>|        | 8bits  | 16bits | 24bits | 32bits | 40bits |
>|--------|--------|--------|--------|--------|--------|
>| SM3    | 0.036s | 0.154s | 1.307s | 11.736s|        |
>| SHA256 | 0.026s | 0.024s | 0.026s | 0.127s | 3.806s |
>

