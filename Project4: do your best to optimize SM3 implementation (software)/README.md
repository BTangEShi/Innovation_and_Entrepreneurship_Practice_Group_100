> ## 原理阐释
> SM3密码杂凑算法是中国国家密码管理局2010年公布的中国商用密码杂凑算法标准。该算法于2012年发布为密码行业标准(GM/T 0004-2012)，2016年发布为国家密码杂凑算法标准(GB/T 32905-2016)。SM3适用于商用密码应用中的数字签名和验证，是在SHA-256基础上改进实现的一种算法，其安全性和SHA-256相当。SM3和MD5的迭代过程类似，也采用Merkle-Damgard结构。消息分组长度为512位，摘要值长度为256位。整个算法的执行过程可以概括成四个步骤：消息填充、消息扩展、迭代压缩、输出结果。
> ### 消息填充
> SM3的消息扩展步骤是以512位的数据分组作为输入的。因此，我们需要在一开始就把数据长度填充至512位的倍数。数据填充规则和MD5一样，具体步骤如下：
1、先填充一个“1”，后面加上k个“0”。其中k是满足(n+1+k) mod 512 = 448的最小正整数。
2、追加64位的数据长度（bit为单位，大端序存放。观察算法标准原文附录A运算示例可以推知。）
>### 消息扩展
> SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再用这16个消息字递推生成剩余的116个消息字。
>### 迭代压缩
> 
>
>
>![cycle](Pollard_rho_cycle.png)
>
>
>但是，用到哈希函数碰撞上，效果应该不如生日碰撞攻击。但是，它的空间复杂度较低，且针对一些具有周期性的hash函数具有良好的寻找碰撞效果。
> ## 代码说明
> 我们已经使用c++代码完成了SM3的实现。但是，考虑到攻击的方便性，我们本次实验使用python的gmssl库完成SM3的碰撞攻击的实现。并且，通过引入python的hashlib库完成sha256的碰撞攻击的实现来进行相应的对照。具体代码细节实现如下：
> 
>    ```python
>    def Rho_SM3(num):
      item=b"202100460120"
      Hash1=SM3(item)
      Hash2=SM3(Hash1)
      while(True):
          if(Hash1[0:num]!=Hash2[0:num]):
              Hash1=SM3(Hash1)
              Hash2=SM3(SM3(Hash2))
          else:
              print(Hash1)
              print(Hash2)
              break
> ``` python
> def Rho_SHA256(num):
      item=b"202100460120"
      Hash1=SHA256(item)
      Hash2=SHA256(Hash1)
      while(True):
          if(Hash1[0:num]!=Hash2[0:num]):
              Hash1=SHA256(Hash1)
              Hash2=SHA256(SHA256(Hash2))
          else:
              print(Hash1)
              print(Hash2)
              break

>
>
>观察上述代码可知,我将自己的学号输入，来作为初始项来寻找碰撞。我们可以看到当碰撞条件不成立时，这样两个hash值分别进行一次和两次的hash，从而形成“龟兔赛跑”之势。


>## 结果展示
>8bits
>![8bits](8bits.png)
>
>16bits
>![16bits](16bits.png)
>
>24bits
>![24bits](24bits.png)
>
>32bits
>![32bits](32bits.png)
>
>40bits
>![40bits](40bits.png)


>|        | 8bits  | 16bits | 24bits | 32bits | 40bits |
>|--------|--------|--------|--------|--------|--------|
>| SM3    | 0.036s | 0.154s | 1.307s | 11.736s|        |
>| SHA256 | 0.026s | 0.024s | 0.026s | 0.127s | 3.806s |
>

